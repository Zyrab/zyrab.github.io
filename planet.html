

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Spaceship in WebGL</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      overflow: hidden;
      background-color: black;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .container {
      position: relative;
      width: 300px;
      height: 500px;
    }
    #webglCanvas {
      display: block;
      background-color:hsl(0, 0%, 20%);
    }
    #canvas2D {
      position: absolute;
    }
   
  </style>
</head>

<body>
  <div class="container">
    <canvas id="canvas2D" position="absolute"></canvas>
    <canvas id="webglCanvas"></canvas>
  </div>
</body>
<script type="module" src="/src/components/game/game2d.js"></script>

</html>

<!-- <!DOCTYPE html>
<html>

<head>
  <title>WebGL Explosion</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    canvas {
      margin-top: 20px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 30px;
    }
  </style>
</head>

<body>
  <button id="explode">Explode!</button>
  <canvas id="canvas" width="600" height="400"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    const button = document.getElementById('explode');

    let program;
    let positionLocation;
    let timeLocation;
    let centerLocation;
    let explosions = []; // Store multiple explosions

    function initGL() {
      const vertexShaderSource = `
                attribute vec2 position;
                uniform float time;
                uniform vec2 center;
                varying float vOpacity;

                void main() {
                    vec2 dir = position - center;
                    float dist = length(dir);
                    float speed = 0.5 + 0.5 * fract(time * 0.1);
                    vec2 newPos = center + dir * (1.0 + speed * time);
                    gl_Position = vec4((newPos / vec2(300.0, 200.0)) * 2.0 - 1.0, 0, 1);
                    vOpacity = 1.0 - (time / 2.0);
                    gl_PointSize = 2.0; // Smaller particles
                }
            `;

      const fragmentShaderSource = `
                precision mediump float;
                varying float vOpacity;

                void main() {
                    gl_FragColor = vec4(1.0, 1.0, 1.0, vOpacity);
                }
            `;

      function createShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile error:', gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

      program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
      }
      gl.useProgram(program);

      positionLocation = gl.getAttribLocation(program, 'position');
      timeLocation = gl.getUniformLocation(program, 'time');
      centerLocation = gl.getUniformLocation(program, 'center');

      // Enable blending for a glowing effect
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    }

    function generateParticles(count = 500) {
      const data = new Float32Array(count * 2);
      const centerX =  Math.random() * 200;
      const centerY = Math.random() * 100;

      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 8;
        data[i * 3] = centerX + Math.cos(angle) * radius;
        data[i * 2 + 1] = centerY + Math.sin(angle) * radius;
      }

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
      return { buffer, center: { x: centerX, y: centerY }, startTime: Date.now() };
    }

    function animate() {
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);

      // Render all explosions
      explosions.forEach((explosion, index) => {
        const time = (Date.now() - explosion.startTime) / 500;

        if (time > 2.0) {
          explosions.splice(index, 1); // Remove expired explosions
          return;
        }

        // Map center coordinates to NDC
        const centerNDC = {
          x: explosion.center.x,
          y: explosion.center.y,
        };
        gl.uniform2f(centerLocation, centerNDC.x, centerNDC.y);
        gl.uniform1f(timeLocation, time);

        gl.bindBuffer(gl.ARRAY_BUFFER, explosion.buffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.POINTS, 0, 1000); // Draw 1000 particles
      });

      requestAnimationFrame(animate);
    }

    button.addEventListener('click', () => {
      // Add a new explosion
      explosions.push(generateParticles(1000));
    });

    initGL();
    animate(); // Start the animation loop
  </script>
</body>

</html> -->